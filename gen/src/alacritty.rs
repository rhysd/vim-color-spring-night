use crate::palette::Palette;
use std::fmt;
use std::io::{Result, Write};

#[derive(Clone, Copy, Debug)]
enum Brightness {
    Dim,
    Normal,
    Bright,
}

impl fmt::Display for Brightness {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Dim => write!(f, "dim"),
            Self::Normal => write!(f, "normal"),
            Self::Bright => write!(f, "bright"),
        }
    }
}

#[derive(Debug)]
struct AnsiColors<'a> {
    brightness: Brightness,
    foreground: &'a str,
    black: &'a str,
    red: &'a str,
    green: &'a str,
    yellow: &'a str,
    blue: &'a str,
    magenta: &'a str,
    cyan: &'a str,
    white: &'a str,
}

type Color<'a> = (&'a str, &'a str); // Pair of foreground/background colors

#[derive(Debug)]
pub struct AlacrittyTheme<'a> {
    palette: &'a Palette,
    background: &'a str,
    dim: AnsiColors<'a>,
    normal: AnsiColors<'a>,
    bright: AnsiColors<'a>,
    search: Color<'a>,
    search_focus: Color<'a>,
    footer_bar: Color<'a>,
    line_indicator: Color<'a>,
    hint_head: Color<'a>,
    hint_tail: Color<'a>,
}

impl<'a> AlacrittyTheme<'a> {
    pub fn new(palette: &'a Palette) -> Self {
        Self {
            palette,
            background: "bg",
            dim: AnsiColors {
                brightness: Brightness::Dim,
                foreground: "yellow",
                black: "black",
                red: "mildred",
                green: "darkgreen",
                yellow: "dullgold",
                blue: "blue",
                magenta: "fuchsia",
                cyan: "cloudy",
                white: "gray",
            },
            normal: AnsiColors {
                brightness: Brightness::Normal,
                foreground: "fg",
                black: "black",
                red: "crimson",
                green: "green",
                yellow: "gold",
                blue: "blue",
                magenta: "purple",
                cyan: "skyblue",
                white: "white",
            },
            bright: AnsiColors {
                brightness: Brightness::Bright,
                foreground: "fg",
                black: "gray",
                red: "red",
                green: "lime",
                yellow: "yellow",
                blue: "paleblue",
                magenta: "purple",
                cyan: "sunny",
                white: "white",
            },
            search: ("fg", "sakura"),
            search_focus: ("white", "kakezakura"),
            footer_bar: ("fg", "bgstrong"),
            line_indicator: ("fg", "yaezakura"),
            hint_head: ("bg", "mikan"),
            hint_tail: ("bg", "orange"),
        }
    }

    fn color(&self, name: &str) -> &'_ str {
        self.palette[name].gui.normal()
    }

    fn write_color(&self, w: &mut impl Write, name: &str, (fg, bg): Color<'_>) -> Result<()> {
        let (fg, bg) = (self.color(fg), self.color(bg));
        writeln!(
            w,
            r#"{name} = {{ foreground = "{fg}", background = "{bg}" }}"#,
        )
    }

    fn write_header_comment(&self, w: &mut impl Write) -> Result<()> {
        writeln!(
            w,
            r#"# Alacritty theme for spring-night colorscheme
#
# Author: rhysd <lin90162@yahoo.co.jp>
# License: MIT
#   Copyright (c) 2016 rhysd
#
# PLEASE DO NOT MODIFY THIS FILE DIRECTLY!
# Generated by script vim-color-spring-night/gen/{file}"#,
            file = file!(),
        )
    }

    fn write_root_section(&self, w: &mut impl Write) -> Result<()> {
        writeln!(w)?;
        writeln!(w, "[colors]")?;
        self.write_color(w, "footer_bar", self.footer_bar)?;
        self.write_color(w, "line_indicator", self.line_indicator)
    }

    #[rustfmt::skip]
    fn write_primary_section(&self, w: &mut impl Write) -> Result<()> {
        writeln!(w)?;
        writeln!(w, "[colors.primary]")?;
        writeln!(w, "background = \"{}\"",        self.color(self.background))?;
        writeln!(w, "foreground = \"{}\"",        self.color(self.normal.foreground))?;
        writeln!(w, "dim_foreground = \"{}\"",    self.color(self.dim.foreground))?;
        writeln!(w, "bright_foreground = \"{}\"", self.color(self.bright.foreground))
    }

    #[rustfmt::skip]
    fn write_ansi_colors_section(&self, w: &mut impl Write, colors: &AnsiColors<'a>) -> Result<()> {
        writeln!(w)?;
        writeln!(w, "[colors.{}]",      colors.brightness)?;
        writeln!(w, "black = \"{}\"",   self.color(colors.black))?;
        writeln!(w, "red = \"{}\"",     self.color(colors.red))?;
        writeln!(w, "green = \"{}\"",   self.color(colors.green))?;
        writeln!(w, "yellow = \"{}\"",  self.color(colors.yellow))?;
        writeln!(w, "blue = \"{}\"",    self.color(colors.blue))?;
        writeln!(w, "magenta = \"{}\"", self.color(colors.magenta))?;
        writeln!(w, "cyan = \"{}\"",    self.color(colors.cyan))?;
        writeln!(w, "white = \"{}\"",   self.color(colors.white))
    }

    fn write_search_section(&self, w: &mut impl Write) -> Result<()> {
        writeln!(w)?;
        writeln!(w, "[colors.search]")?;
        self.write_color(w, "matches", self.search)?;
        self.write_color(w, "focused_match", self.search_focus)
    }

    fn write_hints_section(&self, w: &mut impl Write) -> Result<()> {
        writeln!(w)?;
        writeln!(w, "[colors.hints]")?;
        self.write_color(w, "start", self.hint_head)?;
        self.write_color(w, "end", self.hint_tail)
    }

    pub fn write_to(&self, w: &mut impl Write) -> Result<()> {
        self.write_header_comment(w)?;
        self.write_root_section(w)?;
        self.write_primary_section(w)?;
        for colors in [&self.dim, &self.normal, &self.bright] {
            self.write_ansi_colors_section(w, colors)?;
        }
        self.write_search_section(w)?;
        self.write_hints_section(w)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use regex::Regex;
    use std::str;
    use toml_edit::{DocumentMut, Item as TomlItem, Value as TomlValue};

    #[test]
    fn test_default_alacritty_theme() {
        let p = Palette::default();
        let w = AlacrittyTheme::new(&p);
        let mut out = vec![];
        w.write_to(&mut out).unwrap();
        let src = str::from_utf8(&out).unwrap();
        let doc: DocumentMut = src.parse().expect(src);

        let hex_color = Regex::new(r"^#[[:xdigit:]]{6}$").unwrap();
        let assert_color = move |path: &str| {
            let mut item = doc.as_item();
            for idx in path.split('.') {
                item = item.get(idx).expect(path);
            }
            let TomlItem::Value(v) = item else {
                panic!("{path} is not a primitive: {item:?}");
            };
            let TomlValue::String(s) = v else {
                panic!("{path} is not a string: {v:?}");
            };
            let s = s.value().as_str();
            assert!(hex_color.is_match(s), "{path} is not a hex color: {s:?}");
        };

        for path in [
            "foreground",
            "background",
            "dim_foreground",
            "bright_foreground",
        ] {
            assert_color(&format!("colors.primary.{path}"));
        }

        for mode in ["dim", "normal", "bright"] {
            for color in [
                "black", "red", "green", "yellow", "blue", "magenta", "cyan", "white",
            ] {
                assert_color(&format!("colors.{mode}.{color}"));
            }
        }

        for section in [
            "search.matches",
            "search.focused_match",
            "footer_bar",
            "line_indicator",
        ] {
            for color in ["foreground", "background"] {
                assert_color(&format!("colors.{section}.{color}"));
            }
        }
    }
}
