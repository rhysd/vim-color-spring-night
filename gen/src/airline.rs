use crate::palette::Palette;
use std::collections::HashMap;
use std::io::{Result, Write};

#[derive(Debug, PartialEq, Default)]
struct ModeColors<'a> {
    label: (&'a str, &'a str),
    info: (&'a str, &'a str),
    main: (&'a str, &'a str),
    modified: Option<&'a str>,
    modified_main: Option<&'a str>,
}

#[derive(Debug)]
pub struct AirlineTheme<'a> {
    palette: &'a Palette,
    modes: HashMap<&'a str, ModeColors<'a>>,
    paste: &'a str,
    info_mod: &'a str,
    error: (&'a str, &'a str),
    warning: (&'a str, &'a str),
}

impl<'a> AirlineTheme<'a> {
    pub fn new(palette: &'a Palette) -> Self {
        //  Note: Pairs of strings are color names of (fg, bg)
        let mut modes = HashMap::new();
        let mut mode_colors = |name, colors| assert_eq!(modes.insert(name, colors), None);

        mode_colors(
            "normal",
            ModeColors {
                label: ("bg", "gold"),
                info: ("gold", "hiddenfg"),
                main: ("yellow", "bglight"),
                modified: Some("green"),
                modified_main: Some("whitegreen"),
            },
        );
        mode_colors(
            "insert",
            ModeColors {
                label: ("bg", "skyblue"),
                info: ("skyblue", "hiddenfg"),
                main: ("whiteblue", "bglight"),
                modified: None,
                modified_main: None,
            },
        );
        mode_colors(
            "visual",
            ModeColors {
                label: ("bg", "kakezakura"),
                info: ("kakezakura", "hiddenfg"),
                main: ("whitepink", "bglight"),
                modified: Some("sakura"),
                modified_main: None,
            },
        );
        mode_colors(
            "replace",
            ModeColors {
                label: ("bg", "red"),
                info: ("red", "hiddenfg"),
                main: ("whitered", "bglight"),
                modified: Some("crimson"),
                modified_main: None,
            },
        );
        mode_colors(
            "inactive",
            ModeColors {
                label: ("weakfg", "bglight"),
                info: ("weakfg", "bglight"),
                main: ("weakfg", "bglight"),
                modified: None,
                modified_main: None,
            },
        );

        Self {
            palette,
            modes,
            paste: "mikan",
            info_mod: "hiddenfg",
            error: ("bg", "red"),
            warning: ("bg", "mikan"),
        }
    }

    fn write_header(&self, w: &mut impl Write) -> Result<()> {
        let red = &self.palette["red"];
        // Header
        write!(
            w,
            r#"" vim-airline theme for spring-night colorscheme
"
" Author: rhysd <lin90162@yahoo.co.jp>
" License: MIT
"   Copyright (c) 2016 rhysd
"
" PLEASE DO NOT MODIFY THIS FILE DIRECTLY!
" Generated by script vim-color-spring-night/gen/{source}

let g:airline#themes#spring_night#palette = {{}}

let g:airline#themes#spring_night#palette.accents = {{
\   'red': ['{guifg}', '', {ctermfg}, '', ''],
\ }}

"#,
            source = file!(),
            guifg = red.gui.normal(),
            ctermfg = red.cterm.normal(),
        )
    }

    fn write_section_color(
        &self,
        w: &mut impl Write,
        name: &str,
        (fg, bg): (&'a str, &'a str),
    ) -> Result<()> {
        let fg = &self.palette[fg];
        let bg = &self.palette[bg];
        writeln!(
            w,
            "\\   'airline_{name}': ['{gui_fg}', '{gui_bg}', {cterm_fg}, {cterm_bg}, ''],",
            gui_fg = fg.gui.normal(),
            gui_bg = bg.gui.normal(),
            cterm_fg = fg.cterm.normal(),
            cterm_bg = bg.cterm.normal(),
        )
    }

    fn write_error_warning(&self, w: &mut impl Write) -> Result<()> {
        self.write_section_color(w, "error", self.error)?;
        self.write_section_color(w, "warning", self.warning)
    }

    fn write_mode_colors(&self, w: &mut impl Write, name: &str) -> Result<()> {
        let mode = &self.modes[name];

        writeln!(w, "let g:airline#themes#spring_night#palette.{name} = {{")?;
        self.write_section_color(w, "a", mode.label)?;
        self.write_section_color(w, "b", mode.info)?;
        self.write_section_color(w, "c", mode.main)?;
        self.write_section_color(w, "x", mode.main)?;
        self.write_section_color(w, "y", mode.info)?;
        self.write_section_color(w, "z", mode.label)?;
        self.write_error_warning(w)?;
        writeln!(w, "\\ }}")?;

        if let Some(modified) = mode.modified {
            let main_fg = mode.modified_main.unwrap_or(modified);
            writeln!(
                w,
                "let g:airline#themes#spring_night#palette.{name}_modified = {{",
            )?;
            self.write_section_color(w, "a", (mode.label.0, modified))?;
            self.write_section_color(w, "b", (modified, self.info_mod))?;
            self.write_section_color(w, "c", (main_fg, mode.main.1))?;
            self.write_error_warning(w)?;
            writeln!(w, "\\ }}")?;
        }

        writeln!(w)
    }

    pub fn write_to(&self, w: &mut impl Write) -> Result<()> {
        self.write_header(w)?;

        for mode in &["normal", "insert", "visual", "replace", "inactive"] {
            self.write_mode_colors(w, mode)?;
        }

        let normal_map = &self.modes["normal"];
        let insert_map = &self.modes["insert"];

        // Insert Paste
        writeln!(
            w,
            "let g:airline#themes#spring_night#palette.insert_paste = {{",
        )?;
        self.write_section_color(w, "a", (insert_map.label.0, self.paste))?;
        self.write_section_color(w, "b", (self.paste, self.info_mod))?;
        self.write_section_color(w, "c", (self.paste, normal_map.main.1))?;
        self.write_error_warning(w)?;
        writeln!(w, "\\ }}\n")?;

        // Inactive Modified is a special case
        writeln!(
            w,
            "let g:airline#themes#spring_night#palette.inactive_modified = {{",
        )?;
        let modified = &self.palette[normal_map.modified.unwrap()];
        let guifg = modified.gui.normal();
        let ctermfg = modified.cterm.normal();
        writeln!(w, "\\   'airline_c': ['{guifg}', '', {ctermfg}, '', ''],")?;
        self.write_error_warning(w)?;
        writeln!(w, "\\ }}")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::palette::{Color, ColorCode};
    use regex::Regex;
    use std::str;

    #[test]
    fn test_write_theme() {
        let mut m = HashMap::new();
        m.insert(
            "color1",
            Color {
                gui: ColorCode::Normal("#123456"),
                cterm: ColorCode::Normal(123),
            },
        );
        m.insert(
            "color2",
            Color {
                gui: ColorCode::Contrast("#000000", "#ffffff"),
                cterm: ColorCode::Contrast(1, 2),
            },
        );
        // Userd for accents
        m.insert(
            "red",
            Color {
                gui: ColorCode::Normal("#ff0000"),
                cterm: ColorCode::Normal(123),
            },
        );

        let palette = Palette::from(m);
        let w = AirlineTheme {
            palette: &palette,
            modes: {
                let mut m = HashMap::new();
                m.insert(
                    "normal",
                    ModeColors {
                        label: ("color1", "color2"),
                        info: ("color2", "color1"),
                        main: ("color2", "color2"),
                        modified: Some("color1"),
                        modified_main: Some("color1"),
                    },
                );
                m.insert(
                    "insert",
                    ModeColors {
                        label: ("color2", "color1"),
                        info: ("color1", "color2"),
                        main: ("color1", "color1"),
                        modified: Some("color1"),
                        modified_main: None,
                    },
                );
                m.insert(
                    "visual",
                    ModeColors {
                        label: ("color1", "color1"),
                        info: ("color2", "color2"),
                        main: ("color1", "color1"),
                        modified: None,
                        modified_main: None,
                    },
                );
                m.insert(
                    "replace",
                    ModeColors {
                        label: ("color1", "color1"),
                        info: ("color2", "color2"),
                        main: ("color1", "color1"),
                        modified: Some("color1"),
                        modified_main: None,
                    },
                );
                m.insert(
                    "inactive",
                    ModeColors {
                        label: ("color1", "color1"),
                        info: ("color2", "color2"),
                        main: ("color1", "color1"),
                        modified: Some("color2"),
                        modified_main: Some("color2"),
                    },
                );
                m
            },
            paste: "color1",
            info_mod: "color2",
            error: ("color1", "color2"),
            warning: ("color2", "color1"),
        };

        let mut out = vec![];
        w.write_to(&mut out).unwrap();
        let rendered = str::from_utf8(&out).unwrap();

        let re_var = Regex::new(r"^let g:airline#themes#spring_night#palette\.(\w+) =").unwrap();
        let re_palette =
            Regex::new(r"^\\\s+'(red|airline_(a|b|c|x|y|z|error|warning))': \[('(#[[:xdigit:]]{6})?',\s*){2}((\d{1,3}|''),\s*){2}''\]").unwrap();
        for line in rendered.lines() {
            if line.starts_with("let g:") {
                match re_var.captures(line) {
                    Some(found) => {
                        let mode = &found[1];
                        assert!(
                            w.modes.keys().any(|m| *m == mode
                                || format!("{}_modified", m) == mode
                                || format!("{}_paste", m) == mode
                                || "accents" == mode),
                            "Unknown mode: {}",
                            mode
                        );
                    }
                    None => assert!(
                        line == "let g:airline#themes#spring_night#palette = {}",
                        "Invalid variable definition: {}",
                        line
                    ),
                }
            } else if line.starts_with("\\   ") {
                assert!(re_palette.is_match(line), "Invalid color palette: {}", line);
            }
        }
    }
}
